"use strict";(self.webpackChunkModDocCE=self.webpackChunkModDocCE||[]).push([[785],{3905:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"mobile/overview","title":"Overview","description":"This is not for the faint of heart! This section goes in-depth into the internals of how Dead Cells is ported to mobile, how it runs, and how to effectively mod it.","source":"@site/docs/mobile/overview.md","sourceDirName":"mobile","slug":"/mobile/overview","permalink":"/ModDocCE/mobile/overview","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Mobile","permalink":"/ModDocCE/category/mobile"},"next":{"title":"PAK File Preprocessing","permalink":"/ModDocCE/mobile/pak_splitting"}}');var o=t(4848),a=t(8453);const s={sidebar_position:1},r="Overview",l={},d=[{value:"HL/C and ARM Cross-Compilation",id:"hlc-and-arm-cross-compilation",level:2},{value:"Platform-Specific Wrappers",id:"platform-specific-wrappers",level:2},{value:"PAK Files",id:"pak-files",level:2},{value:"So what can we do?",id:"so-what-can-we-do",level:2}];function c(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"overview",children:"Overview"})}),"\n",(0,o.jsx)(i.admonition,{type:"danger",children:(0,o.jsx)(i.p,{children:"This is not for the faint of heart! This section goes in-depth into the internals of how Dead Cells is ported to mobile, how it runs, and how to effectively mod it."})}),"\n",(0,o.jsx)(i.p,{children:"As you should (hopefully) already know, Dead Cells is a Hashlink game. However, production desktop builds of it use Hashlink bytecode, which is very easy to patch and decompile, thankfully for us! On mobile, though, we're not as lucky."}),"\n",(0,o.jsx)(i.h2,{id:"hlc-and-arm-cross-compilation",children:"HL/C and ARM Cross-Compilation"}),"\n",(0,o.jsx)(i.p,{children:"HL/C is a transpiler that can take Hashlink bytecode and fully convert it to C source code that can be compiled and run with a lot less overhead than the full dynamic VM (or the profiling VM written in OCaml as part of the Haxe toolchain). As well as this, the Hashlink VM isn't supported on ARM at all - only on x86 and x64. This means that Playdigious had two options when porting HL games to mobile:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Completely rewrite and reimplement the (incredibly complex and weird) HL VM so that it can run fully on ARM"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Or:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Use the tooling that already exists and already supports ARM (HL/C) to compile a faster native binary directly for the target platform."}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Obvious, you can guess which option they picked. This is inconvenient for us, though, sine we lose a lot of high-level debug information from the bytecode, and we lose the ability to easily patch the bytecode, and are forced instead to patch the resulting compiled assembly more directly."}),"\n",(0,o.jsxs)(i.p,{children:["Android systems run either ARM (",(0,o.jsx)(i.em,{children:"usually"})," aarch64) or x86/x64, and iPhones are ARM (aarch64). Mobile builds of Dead Cells only target aarch64, which isn't too big of a deal considering their prevalence nowadays on the mobile market. This ",(0,o.jsx)(i.em,{children:"does"})," raise some interesting questions about whether or not the HL VM could be more directly ported to Android running on x86, but that's a question for another day. The important takeaway from this section is that:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Whereas the PC builds of DC are HL VM bytecode that can be inspected and patched easily..."}),"\n",(0,o.jsxs)(i.li,{children:["Mobile builds of DC are assembly directly compiled from HL/C translations of the same original HL VM bytecode","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"This removes a lot of useful information and makes our ability to core mod/patch much more limited and low-level"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"platform-specific-wrappers",children:"Platform-Specific Wrappers"}),"\n",(0,o.jsx)(i.p,{children:"Great! Now, we have a piece of native code that can run on our target mobile system's CPU directly. However, we still need to give it input from the OS's interfaces, and route output back to the OS - this is where a wrapper comes in. On Android, this is written in Java, and can be very easily decompiled and inspected:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'public class DeadCells extends SDLActivity {\r\n    static String LOG_TAG = "DEADCELLS";\r\n    private boolean initAssetsHasBeenCalled = false;\r\n\r\n    public static native void initAndroidUtils(String str, String str2);\r\n\r\n    public static native void initUtils(int i, boolean z);\r\n\r\n    public static native void togglePauseStatus(boolean z);\r\n\r\n    protected void onCreate(Bundle bundle) {\r\n        ReLinker.recursively().loadLibrary(this, "native-lib");\r\n        //...\r\n        ThirdPartySDK.onCreate(bundle);\r\n        //...\r\n    }\r\n\r\n    public void onBackPressed() {\r\n        log("onBackPressed called");\r\n        if (!"googleplay".equals("bilibiliuo")) {\r\n            super.onBackPressed();\r\n        }\r\n        ThirdPartySDK.onBackPressed();\r\n    }\r\n\r\n    // and a whole bunch more funtions like this...\n'})}),"\n",(0,o.jsxs)(i.p,{children:["As you can see, the main Activity class just basically proxies information to and from the native lib, ",(0,o.jsx)(i.code,{children:"libnative-lib.so"}),". This massive (~50MB) binary contains the entire compiled DC codebase, as generated by Hl/C. You can find this in the ",(0,o.jsx)(i.code,{children:"lib/arm64-v8a/"})," of the Android builds - we'll get to iOS in a seperate document, because handling it is infinitely more complicated than Android."]}),"\n",(0,o.jsx)(i.admonition,{type:"note",children:(0,o.jsx)(i.p,{children:"Remarkably, on Android builds, debug information wasn't stripped from the final build - so function names and type information are still there. It may, in fact, even be possible to recover a lot of bytecode metadata or even some opcodes through pattern matching and clever parsing of the debug symbols."})}),"\n",(0,o.jsx)(i.h2,{id:"pak-files",children:"PAK Files"}),"\n",(0,o.jsxs)(i.p,{children:["Ideally, you should have already read the ",(0,o.jsx)(i.a,{href:"/files/pak",children:"other page on the PAK format"}),", but you don't ",(0,o.jsx)(i.em,{children:"really"})," need it. The mobile PAK files still work basically the same as those of the desktop version - they're just split between a few files. THe layered loading system used in the desktop versions of the game still very much applies."]}),"\n",(0,o.jsx)(i.p,{children:"It is still unclear if the game will find additional PAKs if they are added to the app bundle of the game. The paths for the PAKs may be hardcoded into the compiled binary."}),"\n",(0,o.jsx)(i.h2,{id:"so-what-can-we-do",children:"So what can we do?"}),"\n",(0,o.jsx)(i.p,{children:"It's completely possible to repack the mobile versions of Dead Cells with custom changes to files. You can pretty easily:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Apply small changes to PAK files and assets"}),"\n",(0,o.jsx)(i.li,{children:"Replace PAKs altogether"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"You cannot, however, use DCCM or other modding frameworks at all, since they rely on being able to control the HL VM, which does not exist at all with HL/C compilation."})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>s,x:()=>r});var n=t(6540);const o={},a=n.createContext(o);function s(e){const i=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(a.Provider,{value:i},e.children)}}}]);