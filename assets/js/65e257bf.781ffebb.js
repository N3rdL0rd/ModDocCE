"use strict";(self.webpackChunkModDocCE=self.webpackChunkModDocCE||[]).push([[593],{4282:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>d,default:()=>o,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"files/pak","title":"PAK files","description":"PAK files are checksum-verified packages that contain a full filesystem structure inside them - they store all assets for the game. PAK files can be layered on top of each other - the game will first search for res.pak, then res1.pak, then res2.pak (etc.) while loading PAKs - PAKs are incrementally stacked on top of each other during the loading process - conflicts are ignored, and the PAK with the highest priority is used.","source":"@site/docs/files/pak.md","sourceDirName":"files","slug":"/files/pak","permalink":"/ModDocCE/files/pak","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"File Formats","permalink":"/ModDocCE/category/file-formats"},"next":{"title":"HashLink bytecode (and hlboot.dat)","permalink":"/ModDocCE/files/hlboot"}}');var n=i(4848),l=i(8453);const r={sidebar_position:1},d="PAK files",h={},c=[{value:"Format",id:"format",level:2},{value:"File",id:"file",level:3},{value:"Header",id:"header",level:3},{value:"Entry",id:"entry",level:3},{value:"If the entry is a directory",id:"if-the-entry-is-a-directory",level:4},{value:"If the entry is a file",id:"if-the-entry-is-a-file",level:4},{value:"DATA marker",id:"data-marker",level:3},{value:"Stamps",id:"stamps",level:2}];function a(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"pak-files",children:"PAK files"})}),"\n",(0,n.jsxs)(t.p,{children:["PAK files are checksum-verified packages that contain a full filesystem structure inside them - they store all assets for the game. PAK files can be layered on top of each other - the game will first search for ",(0,n.jsx)(t.code,{children:"res.pak"}),", then ",(0,n.jsx)(t.code,{children:"res1.pak"}),", then ",(0,n.jsx)(t.code,{children:"res2.pak"})," (etc.) while loading PAKs - PAKs are incrementally stacked on top of each other during the loading process - conflicts are ignored, and the PAK with the highest priority is used."]}),"\n",(0,n.jsx)(t.h2,{id:"format",children:"Format"}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsxs)(t.p,{children:["If you're a REHex user, you can download a fully commented out example PAK file from ",(0,n.jsx)(t.a,{href:"https://n3rdl0rd.github.io/alivecells/stamptool/example.pak.zip",children:"here"})]})}),"\n",(0,n.jsx)(t.h3,{id:"file",children:"File"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Size (bytes)"}),(0,n.jsx)(t.th,{children:"Name"}),(0,n.jsx)(t.th,{children:"Description"}),(0,n.jsx)(t.th,{children:"Struct"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Variable"}),(0,n.jsx)(t.td,{children:"Header"}),(0,n.jsx)(t.td,{children:"File magic, version, data sizes, stamp"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.a,{href:"#header",children:"Header"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Variable"}),(0,n.jsx)(t.td,{children:"Root directory"}),(0,n.jsx)(t.td,{children:"Main directory entry, contains all data in the PAK"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.a,{href:"#entry",children:"Entry"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"4"}),(0,n.jsx)(t.td,{children:"DATA marker"}),(0,n.jsx)(t.td,{children:"Marks the start of file content data"}),(0,n.jsx)(t.td,{children:(0,n.jsx)(t.a,{href:"#data-marker",children:"DATA marker"})})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Variable"}),(0,n.jsx)(t.td,{children:"File contents"}),(0,n.jsx)(t.td,{children:"Actual file data for all files in the PAK"}),(0,n.jsx)(t.td,{children:"Raw binary data"})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"header",children:"Header"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Size (bytes)"}),(0,n.jsx)(t.th,{children:"Name"}),(0,n.jsx)(t.th,{children:"Description"}),(0,n.jsx)(t.th,{children:"Struct"}),(0,n.jsx)(t.th,{children:"Condition"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"3"}),(0,n.jsx)(t.td,{children:"Magic"}),(0,n.jsx)(t.td,{children:'"PAK"'}),(0,n.jsx)(t.td,{children:"ASCII-encoded text"}),(0,n.jsx)(t.td,{children:"None"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"1"}),(0,n.jsx)(t.td,{children:"Version"}),(0,n.jsx)(t.td,{children:"0x00 or 0x01 - v0 doesn't support stamping, v1 does"}),(0,n.jsx)(t.td,{children:"Unsigned byte"}),(0,n.jsx)(t.td,{children:"None"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"4"}),(0,n.jsx)(t.td,{children:"Header size"}),(0,n.jsx)(t.td,{children:"Size of the header - at v0, guaranteed to be >16, at v1, guaranteed to be >80"}),(0,n.jsx)(t.td,{children:"Signed 32-bit int"}),(0,n.jsx)(t.td,{children:"None"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"4"}),(0,n.jsx)(t.td,{children:"Data size"}),(0,n.jsx)(t.td,{children:"Size of the data"}),(0,n.jsx)(t.td,{children:"Signed 32-bit int"}),(0,n.jsx)(t.td,{children:"None"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"64"}),(0,n.jsx)(t.td,{children:"Stamp"}),(0,n.jsxs)(t.td,{children:["Signature based on git commit - see ",(0,n.jsx)(t.a,{href:"#stamps",children:"here"})]}),(0,n.jsx)(t.td,{children:"ASCII-encoded text"}),(0,n.jsx)(t.td,{children:"Game >=v35, PAK >=v1"})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"entry",children:"Entry"}),"\n",(0,n.jsxs)(t.p,{children:["An Entry can either be a directory or a file, determined by its ",(0,n.jsx)(t.code,{children:"Flags"}),"."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Size (bytes)"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Struct"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"1"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Name length"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"The number of characters in the name."}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Unsigned byte"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Variable"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Name"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"The name of the entry."}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"ASCII text"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"1"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Flags"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Bit flags that determine the entry type."}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Unsigned byte"})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"Flags"})," field is a bitmask that specifies the properties of the entry:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.code,{children:"&0x01"})}),": If this bit is set, the entry is a ",(0,n.jsx)(t.strong,{children:"directory"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.code,{children:"&0x02"})}),": If this bit is set, the ",(0,n.jsx)(t.code,{children:"Position"})," of the file data is represented as a 64-bit long integer."]}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"0x02"})," flag cannot generally be found in Dead Cells on any platforms - but it exists here for completeness of the format. Dead Cells also does not handle deserialising this flag, but other Heaps games (such as Wartales) generate such PAKs."]})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h4,{id:"if-the-entry-is-a-directory",children:"If the entry is a directory"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Size (bytes)"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Struct"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"4"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Entry count"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"The number of entries inside this directory."}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Signed 32-bit int"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Variable"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Entries"}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["A recursive list of ",(0,n.jsx)(t.code,{children:"Entry"})," structures."]}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.a,{href:"#entry",children:"Entry"})})]})]})]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h4,{id:"if-the-entry-is-a-file",children:"If the entry is a file"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Size (bytes)"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Description"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Struct"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"4 or 8"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Position"}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:["The offset of the file data from the start of the data section. It is a 64-bit ",(0,n.jsx)(t.code,{children:"long"})," if the ",(0,n.jsx)(t.code,{children:"&0x02"})," flag is set; otherwise, it is a 32-bit ",(0,n.jsx)(t.code,{children:"int"}),"."]}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Signed 32-bit int or 64-bit long"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"4"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Size"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"The size of the file data in bytes."}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Signed 32-bit int"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"4"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Checksum"}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"The Adler32 checksum of the file data."}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Signed 32-bit int"})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"data-marker",children:"DATA marker"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Size (bytes)"}),(0,n.jsx)(t.th,{children:"Name"}),(0,n.jsx)(t.th,{children:"Description"}),(0,n.jsx)(t.th,{children:"Struct"})]})}),(0,n.jsx)(t.tbody,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"4"}),(0,n.jsx)(t.td,{children:"Marker"}),(0,n.jsx)(t.td,{children:'ASCII "DATA" to mark start of content'}),(0,n.jsx)(t.td,{children:"ASCII-encoded text"})]})})]}),"\n",(0,n.jsx)(t.p,{children:"The DATA marker serves as a separator between the header/directory information and the actual file contents. It helps in clearly delineating the structure of the PAK file and can be used as a reference point when reading or writing PAK files."}),"\n",(0,n.jsx)(t.h2,{id:"stamps",children:"Stamps"}),"\n",(0,n.jsx)(t.p,{children:'In v35+ of the game (v1 of the PAK format), PAK files now include "stamps". A stamp is a 64-character (ASCII) digest of a SHA256 hash, generated with this formula (written in pseudocode):'}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-txt",children:'ASCII digest(\r\n    SHA256(\r\n        UTF-8 encode("Dc02&0hQC#G0:"),\r\n        UTF-8 encode(Current git commit - short hash)\r\n    )\r\n)\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Due to the deterministic nature of SHA256 and the short length of the commit hash, it is possible to easily brute-force the short hash from a given stamp - an implementation of this exists in Alive Cells' ",(0,n.jsx)(t.a,{href:"https://github.com/N3rdL0rd/alivecells/blob/main/alivecells.py",children:"main script"}),", as the ",(0,n.jsx)(t.code,{children:"commitbrute"})," subcommand. You can also calculate or extract a stamp from a PAK file or from a short hash using the online ",(0,n.jsx)(t.a,{href:"https://n3rdl0rd.github.io/alivecells/stamptool/",children:"stamp calculator"}),"."]})]})}function o(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>d});var s=i(6540);const n={},l=s.createContext(n);function r(e){const t=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(l.Provider,{value:t},e.children)}}}]);