"use strict";(self.webpackChunkModDocCE=self.webpackChunkModDocCE||[]).push([[877],{6996:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>o,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"files/hxbit","title":"hxbit/HXS Data (Save file payloads)","description":"HxBit is a binary serialization and network synchronization library for the Haxe programming language. The corresponding file format, often with an .hxs extension, is designed for speed and efficiency, using a compact binary representation instead of a more verbose text-based format. This makes it ideal for applications requiring fast loading times and a small data footprint, such as games and networked applications.","source":"@site/docs/files/hxbit.md","sourceDirName":"files","slug":"/files/hxbit","permalink":"/ModDocCE/files/hxbit","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Save Files","permalink":"/ModDocCE/files/save"},"next":{"title":"Tutorials","permalink":"/ModDocCE/category/tutorials"}}');var n=s(4848),r=s(8453);const d={sidebar_position:4},a="hxbit/HXS Data (Save file payloads)",l={},c=[{value:"Format",id:"format",level:2},{value:"File Layout",id:"file-layout",level:3},{value:"Header",id:"header",level:3},{value:"Class Definitions",id:"class-definitions",level:3},{value:"Single Class Definition Entry",id:"single-class-definition-entry",level:4},{value:"Schema Section",id:"schema-section",level:3},{value:"Single Schema Entry",id:"single-schema-entry",level:4},{value:"Object Data",id:"object-data",level:3},{value:"Core Data Types",id:"core-data-types",level:2},{value:"VarInt",id:"varint",level:3},{value:"String",id:"string",level:3},{value:"PropType (Property Type)",id:"proptype-property-type",level:3}];function h(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"hxbithxs-data-save-file-payloads",children:"hxbit/HXS Data (Save file payloads)"})}),"\n",(0,n.jsxs)(i.p,{children:["HxBit is a binary serialization and network synchronization library for the Haxe programming language. The corresponding file format, often with an ",(0,n.jsx)(i.code,{children:".hxs"})," extension, is designed for speed and efficiency, using a compact binary representation instead of a more verbose text-based format. This makes it ideal for applications requiring fast loading times and a small data footprint, such as games and networked applications."]}),"\n",(0,n.jsx)(i.p,{children:"Unlike standard Haxe serialization, which uses runtime type checking, HxBit employs macros to generate strictly-typed serialization code. This approach results in very fast I/O operations. The format also supports versioning by storing the schema of each class within the serialized data, which allows for robust handling of data structure changes over time, such as adding or removing fields."}),"\n",(0,n.jsx)(i.h2,{id:"format",children:"Format"}),"\n",(0,n.jsx)(i.p,{children:"An HXS file is a structured binary file composed of a header, class definitions, schema definitions, and the serialized object data."}),"\n",(0,n.jsx)(i.h3,{id:"file-layout",children:"File Layout"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Size (bytes)"}),(0,n.jsx)(i.th,{children:"Name"}),(0,n.jsx)(i.th,{children:"Description"}),(0,n.jsx)(i.th,{children:"Struct"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"4"}),(0,n.jsx)(i.td,{children:"Header"}),(0,n.jsx)(i.td,{children:"File magic and version number."}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"#header",children:"Header"})})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Class Definitions"}),(0,n.jsx)(i.td,{children:"A list of all class types present in the file, terminated by a null marker."}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"#class-definitions",children:"Class Definitions"})})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Schema Section"}),(0,n.jsx)(i.td,{children:"Describes the structure of each class, prefixed by its total size."}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"#schema-section",children:"Schema Section"})})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Object Data"}),(0,n.jsx)(i.td,{children:"The actual instances of the serialized objects, starting with the root object."}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"#object-data",children:"Object Data"})})]})]})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h3,{id:"header",children:"Header"}),"\n",(0,n.jsx)(i.p,{children:"The header is a fixed-size block that identifies the file as being in the HxBit format and specifies its version."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Size (bytes)"}),(0,n.jsx)(i.th,{children:"Name"}),(0,n.jsx)(i.th,{children:"Description"}),(0,n.jsx)(i.th,{children:"Struct"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"3"}),(0,n.jsx)(i.td,{children:"Magic"}),(0,n.jsx)(i.td,{children:'The ASCII string "HXS".'}),(0,n.jsx)(i.td,{children:"ASCII-encoded text"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"Version"}),(0,n.jsxs)(i.td,{children:["The version of the HXS format, typically ",(0,n.jsx)(i.code,{children:"0x01"}),"."]}),(0,n.jsx)(i.td,{children:"Unsigned byte"})]})]})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h3,{id:"class-definitions",children:"Class Definitions"}),"\n",(0,n.jsxs)(i.p,{children:["This section lists all the classes that are serialized in the file. It is a variable-length sequence of ",(0,n.jsx)(i.code,{children:"Class Definition Entry"})," structures. The entire section is terminated by a single ",(0,n.jsx)(i.code,{children:"VarInt"})," with a value of 0, which acts as a null marker for the class name."]}),"\n",(0,n.jsx)(i.h4,{id:"single-class-definition-entry",children:"Single Class Definition Entry"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Size (bytes)"}),(0,n.jsx)(i.th,{children:"Name"}),(0,n.jsx)(i.th,{children:"Description"}),(0,n.jsx)(i.th,{children:"Struct"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Name"}),(0,n.jsx)(i.td,{children:"The fully qualified name of the class."}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"#string",children:"String"})})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"2"}),(0,n.jsx)(i.td,{children:"CLID"}),(0,n.jsx)(i.td,{children:"A 2-byte unique identifier for the class."}),(0,n.jsx)(i.td,{children:"Big-endian unsigned short"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"4"}),(0,n.jsx)(i.td,{children:"CRC32"}),(0,n.jsx)(i.td,{children:"A CRC32 checksum of the class definition."}),(0,n.jsx)(i.td,{children:"Little-endian unsigned int"})]})]})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h3,{id:"schema-section",children:"Schema Section"}),"\n",(0,n.jsx)(i.p,{children:"The schema section provides a detailed description of the data structure for each class, including its fields and their types. This metadata is crucial for deserialization and version management."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Size (bytes)"}),(0,n.jsx)(i.th,{children:"Name"}),(0,n.jsx)(i.th,{children:"Description"}),(0,n.jsx)(i.th,{children:"Struct"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Schema Size"}),(0,n.jsx)(i.td,{children:"The total size of the following schema data in bytes."}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"#varint",children:"VarInt"})})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"Schema Size"})}),(0,n.jsx)(i.td,{children:"Schemas"}),(0,n.jsx)(i.td,{children:"A list of schema definitions for each class."}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"#single-schema-entry",children:"Single Schema Entry"})})]})]})]}),"\n",(0,n.jsx)(i.h4,{id:"single-schema-entry",children:"Single Schema Entry"}),"\n",(0,n.jsx)(i.p,{children:"Each schema entry defines the structure of one class."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Size (bytes)"}),(0,n.jsx)(i.th,{children:"Name"}),(0,n.jsx)(i.th,{children:"Description"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"UID"}),(0,n.jsxs)(i.td,{children:["A unique identifier for this specific schema, encoded as a ",(0,n.jsx)(i.a,{href:"#varint",children:"VarInt"}),". This UID is used in the ",(0,n.jsx)(i.a,{href:"#object-data",children:"Object Data"})," section to reference instances of this type."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"CLID"}),(0,n.jsxs)(i.td,{children:["The corresponding class identifier, matching a ",(0,n.jsx)(i.code,{children:"CLID"})," from the ",(0,n.jsx)(i.a,{href:"#class-definitions",children:"Class Definitions"})," section. Encoded as a ",(0,n.jsx)(i.a,{href:"#varint",children:"VarInt"}),"."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Field Names List"}),(0,n.jsxs)(i.td,{children:["A list of strings representing the names of the class fields. The list is prefixed by its ",(0,n.jsx)(i.code,{children:"count+1"})," as a ",(0,n.jsx)(i.a,{href:"#varint",children:"VarInt"}),". A ",(0,n.jsx)(i.code,{children:"count+1"})," of 1 means an empty list."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Field Types List"}),(0,n.jsxs)(i.td,{children:["A list of ",(0,n.jsx)(i.code,{children:"PropType"})," structures defining the type of each field. The list is prefixed by its ",(0,n.jsx)(i.code,{children:"count+1"})," as a ",(0,n.jsx)(i.a,{href:"#varint",children:"VarInt"}),". A ",(0,n.jsx)(i.code,{children:"count+1"})," of 1 means an empty list."]})]})]})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h3,{id:"object-data",children:"Object Data"}),"\n",(0,n.jsx)(i.p,{children:"This is the main content of the file, containing the serialized data for the root object and any other objects it references. The structure is hierarchical and begins with a reference to the root object. Object references are used to handle shared instances and circular dependencies efficiently."}),"\n",(0,n.jsx)(i.p,{children:"An object is serialized as a reference followed by its payload if it's the first time it's encountered."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Size (bytes)"}),(0,n.jsx)(i.th,{children:"Name"}),(0,n.jsx)(i.th,{children:"Description"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Object Reference"}),(0,n.jsxs)(i.td,{children:["A ",(0,n.jsx)(i.a,{href:"#varint",children:"VarInt"})," representing the object's UID. A value of 0 indicates a ",(0,n.jsx)(i.code,{children:"null"})," reference. If the UID has been seen before, this is all that is written."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Object Payload"}),(0,n.jsxs)(i.td,{children:["If this is the first time an object with this UID is being serialized, its reference is followed by its payload. The payload consists of the concatenated binary data of all its fields, serialized according to its ",(0,n.jsx)(i.a,{href:"#single-schema-entry",children:"Schema"}),"."]})]})]})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h2,{id:"core-data-types",children:"Core Data Types"}),"\n",(0,n.jsx)(i.p,{children:"The HXS format is built upon a set of core data types that are used to represent various kinds of information."}),"\n",(0,n.jsx)(i.h3,{id:"varint",children:"VarInt"}),"\n",(0,n.jsx)(i.p,{children:"A variable-length integer designed to use fewer bytes for smaller numbers."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Condition"}),(0,n.jsx)(i.th,{children:"Size (bytes)"}),(0,n.jsx)(i.th,{children:"Format"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:["Value is between ",(0,n.jsx)(i.code,{children:"0"})," and ",(0,n.jsx)(i.code,{children:"127"})]}),(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"The value is stored directly as a single byte."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:["Value is ",(0,n.jsx)(i.code,{children:"128"})," or greater"]}),(0,n.jsx)(i.td,{children:"5"}),(0,n.jsxs)(i.td,{children:["A marker byte ",(0,n.jsx)(i.code,{children:"0x80"})," followed by the full 32-bit integer value in little-endian format."]})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"string",children:"String"}),"\n",(0,n.jsxs)(i.p,{children:["A string is encoded with a length prefix. This structure allows for ",(0,n.jsx)(i.code,{children:"null"})," strings to be represented compactly."]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Size (bytes)"}),(0,n.jsx)(i.th,{children:"Name"}),(0,n.jsx)(i.th,{children:"Description"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Length+1"}),(0,n.jsxs)(i.td,{children:["The length of the string plus one, encoded as a ",(0,n.jsx)(i.a,{href:"#varint",children:"VarInt"}),". A ",(0,n.jsx)(i.code,{children:"VarInt"})," value of ",(0,n.jsx)(i.code,{children:"0"})," indicates a ",(0,n.jsx)(i.code,{children:"null"})," string. A value of ",(0,n.jsx)(i.code,{children:"1"})," indicates an empty string (",(0,n.jsx)(i.code,{children:'""'}),")."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"Length"})}),(0,n.jsx)(i.td,{children:"UTF-8 Data"}),(0,n.jsxs)(i.td,{children:["The string data encoded in UTF-8. This part is only present if ",(0,n.jsx)(i.code,{children:"Length+1"})," is greater than 1."]})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"proptype-property-type",children:"PropType (Property Type)"}),"\n",(0,n.jsxs)(i.p,{children:["A ",(0,n.jsx)(i.code,{children:"PropType"})," is a type descriptor that defines the type of a schema field. It consists of a ",(0,n.jsx)(i.code,{children:"Kind"})," byte followed by an optional, type-dependent definition payload."]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Size (bytes)"}),(0,n.jsx)(i.th,{children:"Name"}),(0,n.jsx)(i.th,{children:"Description"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"Kind"}),(0,n.jsxs)(i.td,{children:["An unsigned byte indicating the base type (e.g., Int, Float, String, Array, Object). A value of ",(0,n.jsx)(i.code,{children:"0"})," indicates an untyped or null property."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Variable"}),(0,n.jsx)(i.td,{children:"Definition"}),(0,n.jsxs)(i.td,{children:["An optional payload that provides more detail about the type. For example, for an ",(0,n.jsx)(i.code,{children:"PArray"}),", the definition is another ",(0,n.jsx)(i.code,{children:"PropType"})," that describes the type of elements in the array. For a ",(0,n.jsx)(i.code,{children:"PObj"})," (Object), the definition describes the fields of the inline object structure. For simple types like ",(0,n.jsx)(i.code,{children:"PInt"}),", this part is empty."]})]})]})]})]})}function o(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>d,x:()=>a});var t=s(6540);const n={},r=t.createContext(n);function d(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:d(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);